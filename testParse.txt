void CodeBlock::determineBlockType(std::vector<std::string>& allCodeLines, int currentLine, int placeInLine)
{

    //Check to see if current block type is a comment, whether it's a single or multi-line comment
    //at least two characters are needed to initiate the comment
    if (((allCodeLines[currentLine].size() - 1) - placeInLine) >= 2)
    {
        //std::string twoString = std::to_string((allCodeLines[currentLine][placeInLine] + allCodeLines[currentLine][placeInLine + 1]));
        std::string twoString({ allCodeLines[currentLine][placeInLine], allCodeLines[currentLine][placeInLine + 1] });
        if (twoString == "//")
        {
            //We're dealing with a single line comment. The block extends until the end of the current line
            if (debugPrint) std::cout << "Found a single line comment" << std::endl;
            this->blockType = 1;
            this->beginningCharacter = '\n';
            this->endingCharacter = ' ';
            this->beginningCharacterLocation = { currentLine, allCodeLines[currentLine].size() - 1 };
            return;
        }
        else if (twoString == "/*")
        {
            //We're dealing with a multi line comment (although it's possible to have this all
            //on a single line). The block extends until we find the "*/" character combo
            if (debugPrint) std::cout << "Found a multi line comment" << std::endl;
            this->blockType = 2;
            this->beginningCharacter = '*';
            this->endingCharacter = ' ';
            findEndOfMultiLineQuote(allCodeLines, currentLine, placeInLine);
            this->beginningCharacterLocation = { currentLine, placeInLine };
            return;
        }
    }

    //Check to see if the block is a pre-processor command
    if (allCodeLines[currentLine][placeInLine] == '#')
    {
        if (debugPrint) std::cout << "Found a pre-processor command" << std::endl;
        this->blockType = 0;
        this->beginningCharacter = '\n';
        this->endingCharacter = ' ';
        this->beginningCharacterLocation = { currentLine, allCodeLines[currentLine].size() - 1 }; //extends to end of line
        return;
    }
    else if (allCodeLines[currentLine][placeInLine] == ';')
    {
        if (debugPrint) std::cout << "Found a standalone semi-colon" << std::endl;
        this->blockType = 3;
        this->beginningCharacter = ';';
        this->endingCharacter = ' ';
        this->beginningCharacterLocation = { currentLine, placeInLine }; //extends to end of line
        return;
    }

    std::string firstWord = getFirstWord(allCodeLines[currentLine], placeInLine);
    int location = firstWord.size() - 1 + placeInLine; //The location of the charcter at end of the first word

    //Check to see if the block is a loop, if statement, or something similar
    if (contains(blockwords, firstWord)) {
        //**note: an else if block can't be separated between lines, otherwise the else and 
        //the if will be recognized as different. i.e. else if (something) is ok but
        //else
        //   if (something), isn't. It is possible though, to have the part in parentheses 
        //start on another line, i.e.
        //if
        //   (something) would be allowed. Need to make sure that this is taken into account while
        //iterating through the code below

        //need to find out if this is a block with curly braces or without curly braces.
        //If firstWord is "else", we need to check and see if the word "if" comes after it.
        //I so, or, if the word isn't "else" we increment location until we find the appropriate ')'
        //character.
        if (firstWord == "else")
        {
            if (allCodeLines[currentLine][location + 1] != '\n' && getFirstWord(allCodeLines[currentLine], location + 2) == "if")
            {
                findClosingParenthese(allCodeLines, currentLine, placeInLine);
                location = placeInLine;
            }
        }
        else
        {
            findClosingParenthese(allCodeLines, currentLine, placeInLine);
            location = placeInLine;
        }

        //At this point, the location variable will be on a ')' character, or 
        //an 'e' character. In both cases, if the next non-whitespace character is a
        //'{' character then we have a curly brace block, if it's anything else then
        //we have a non-curlybrace block.
        char currentCharacter;
        int scannedLine = currentLine;
        while (true)
        {
            location++;
            if (location == allCodeLines[scannedLine].size())
            {
                location = 0;
                scannedLine++;
            }
            
            currentCharacter = allCodeLines[scannedLine][location];
            if (currentCharacter == ' ' || currentCharacter == '\t' || currentCharacter == '\n' || currentCharacter == '\r') continue;
            
            if (currentCharacter == '{')
            {
                if (debugPrint) std::cout << "Found a curly brace block" << std::endl;
                this->blockType = 5;
                this->beginningCharacter = '{';
                this->endingCharacter = '}';
                this->beginningCharacterLocation = { scannedLine, location };
                return;
            }
            else 
            {
                if (debugPrint) std::cout << "Found a non-curly brace block" << std::endl;
                this->blockType = 4;
                if (firstWord == "else")
                {
                    this->beginningCharacter = ' '; //the space after else ends the block
                    this->beginningCharacterLocation = { currentLine, location - 1 }; //location of the space
                }
                else
                {
                    this->beginningCharacter = ')'; //the end of the parentheses ends the block
                    this->beginningCharacterLocation = { currentLine, placeInLine };
                }
                this->endingCharacter = ' ';
                return;
            }
        }
    }
    else if (contains(types, firstWord) || contains(classes, firstWord))
    {
        //If the first word of the line is a class or built-in type it means one of two things.
        //Either we're about to define a function, i.e. void func() {}, or we're about to define
        //some variables, i.e. int x = 5, y = 6; It will depend on whether we first find an '=',
        //a ';', or a '(' character. If we encounter an '=' of ';' first then the line is for defining variables.

        bool functionFound = false;
        //iterate until we hit one of these characters
        while (true)
        {
            location++;
            if (location == allCodeLines[currentLine].size())
            {
                location = 0;
                currentLine++;
            }

            if (!functionFound)
            {
                if (allCodeLines[currentLine][location] == '=' || allCodeLines[currentLine][location] == ';')
                {
                    if (debugPrint) std::cout << "Found a variable definition block" << std::endl;
                    this->blockType = 3;
                    this->beginningCharacter = ';';
                    this->endingCharacter = ' ';
                    findFirstNonQuoteCharacter(allCodeLines, currentLine, location, ';');
                    this->beginningCharacterLocation = { currentLine, location };
                    return; //this is considered a standard line of code
                }
                else if (allCodeLines[currentLine][location] == '(') functionFound = true;
            }
            else
            {
                //we've either found a function definition, or a function declaration
                if (allCodeLines[currentLine][location] == '{')
                {
                    if (debugPrint) std::cout << "Found a function definition block" << std::endl;
                    this->blockType = 6;
                    this->beginningCharacter = '{';
                    this->endingCharacter = '}';
                    this->beginningCharacterLocation = { currentLine, location };
                    return;
                }
                else if (allCodeLines[currentLine][location] == ';')
                {
                    if (debugPrint) std::cout << "Found a function declaration block" << std::endl;
                    this->blockType = 3;
                    this->beginningCharacter = ';';
                    this->endingCharacter = ' ';
                    this->beginningCharacterLocation = { currentLine, location };
                    return;
                }
            }
        }
    }
    else if (contains(objects, firstWord))
    {
        if (debugPrint) std::cout << "Found a class/struct/enum definition block" << std::endl;
        this->blockType = 6;
        this->beginningCharacter = '{';
        this->endingCharacter = '}';
        findFirstNonQuoteCharacter(allCodeLines, currentLine, location, '{');
        this->beginningCharacterLocation = { currentLine, location };
        return;
    }
    else if (contains(scopes, firstWord))
    {
        //For my purposes I don't need to actually make this a block, treat it as a standard line
        //but have it end with the \n character instead of the ; character
        if (debugPrint) std::cout << "Found a scope block" << std::endl;
        this->blockType = 3;
        this->beginningCharacter = '\n';
        this->endingCharacter = ' ';
        this->beginningCharacterLocation = { currentLine, location };
        return;
    }
    else if (contains(keywords, firstWord))
    {
        //we've found a word like return
        if (debugPrint) std::cout << "Found a keyword block of code" << std::endl;
        this->blockType = 3;
        this->beginningCharacter = ';';
        this->endingCharacter = ' ';
        this->beginningCharacterLocation = { currentLine, location };
        return;
    }

    //If we can't determine what the block is then it must just be a standard block
    //i.e. x += 10; where x is an already predefined variable. It's also possible
    //that we've found a plain semi-colon. For debugging sake I'll treat that 
    //as separate for now
    if (debugPrint) std::cout << "Found a standard block of code" << std::endl;

    this->blockType = 3;
    this->beginningCharacter = ';';
    this->endingCharacter = ' ';
    findFirstNonQuoteCharacter(allCodeLines, currentLine, location, ';');
    this->beginningCharacterLocation = { currentLine, location };
    return;
}
